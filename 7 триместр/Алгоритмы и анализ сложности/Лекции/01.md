# Лекция 1

04.09.20

- [Лекция 1](#лекция-1)
  - [Сложность алгоритмов](#сложность-алгоритмов)
  - [Способы оценки сложности](#способы-оценки-сложности)
    - [Пример - вычисление факториала числа](#пример---вычисление-факториала-числа)
  - [Функции сложности](#функции-сложности)
  - [Методы оценки сложности](#методы-оценки-сложности)
  - [Порядок роста функции](#порядок-роста-функции)
    - [Примеры](#примеры)

## Сложность алгоритмов

Сложность:

- временная (количество элементарных условных операций (ЭУО))

    ЭУО - любая операция с фиксированным временем выполнения (все арифметические операции со скалярными типами данных, операции сравнения, присваивания и т. д.).

- емкостная (байты)

## Способы оценки сложности

1. Экспериментальный

    Проблемы:

    - зависимость от внешних факторов
    - необходимость реализации и зависимость от нее
    - трудность интерполяции и экстраполяции

    __Интерполяция__.

    __Экстраполяция__.

2. Теоретический

    Построение функции сложности алгоритма.

    t<sub>&alpha;</sub>(x) - количество ЭУО, выполняемых алгоритмом &alpha; на входных данных x.

    Проблемы:

    - количество ЭУО не дает точного значения времени выполнения

Для получения точной оценки способы можно комбинировать.

Входными данными x может быть не только число (например, граф или текст). Поэтому вместо входных данных x будем использовать числовую характеристику этих данных - __объем входных данных v(x)__.

t<sub>&alpha;</sub>(v)

### Пример - вычисление факториала числа

Задача: вычислить N!.

```c
int F(int N)
{
    int r = 1; // 1
    for (int i = 2; i <= N; i++) // 1 + N + (N - 1)
    {
        r *= i; // 2 * (N - 1)
    }
    return r; // 1
}
```

t<sub>F</sub>(N) = 1 + 1 + N + (N - 1) + 2 \* (N - 1) + 1= 4 \* N

t<sub>&alpha;</sub>(x)

v(x<sub>1</sub>) = v(x<sub>2</sub>), но время для x<sub>1</sub> не равно времени для x<sub>2</sub> (например, при сортировке массивов).

## Функции сложности

1. Нижняя оценка (сложность в лучшем случае)

    <u>t</u><sub>&alpha;</sub><u>(v)</u> (с чертой внизу) = min(&alpha;(x)) при v(x) = v

2. Верхняя оценка (сложность в худшем случае)

    t<sub>&alpha;</sub>(x) (с чертой вверху) = max(&alpha;(x)) при v(x) = v

3. Средняя оценка (сложность в среднем)

    Учитывает вероятность появления тех или иных входных данных.

    t<sub>&alpha;</sub><sup>\*</sup>(x) (со звездочкой) = &sum;t<sub>&alpha;</sub>(x)\*p(x) при v(x) = v, где P(x) - вероятность появления входных данных x.

## Методы оценки сложности

1. Линейный алгоритм &alpha;: &alpha;<sub>1</sub>, &alpha;<sub>2</sub>, ..., &alpha;<sub>k</sub>

    Сложность считается как сумма сложности всех составляющих

    t<sub>2</sub>(v) = &sum;&alpha;<sub>i</sub>, i=1..k

2. Ветвление &alpha;: if (condition) then &alpha;<sub>1</sub> else &alpha;<sub>2</sub>

    <u>t<sub>&alpha;</sub>(x)</u> = min(&alpha;<sub>1</sub>, &alpha;<sub>2</sub>) + t<sub>condition</sub>

    t<sub>&alpha;</sub>(x) (с чертой вверху) = max(&alpha;<sub>1</sub>, &alpha;<sub>2</sub>) + t<sub>condition</sub>

    t<sub>&alpha;</sub><sup>\*</sup>(x) = t<sub>&alpha;<sub>1</sub></sub> \* p(&alpha;<sub>1</sub>) + t<sub>&alpha;<sub>2</sub></sub> * p(&alpha;<sub>2</sub>) + t<sub>condition</sub>

3. Цикл a

    t<sub>&alpha;</sub> = t<sub>body</sub>(v) \* repeats + t<sub>condition</sub>

    Пример &alpha;: for (i = i<sub>0</sub>, i < i<sub>k</sub>, i++)

    t<sub>&alpha;</sub>(v) = &sum;t<sub>body</sub> + t<sub>indexes</sub>, i=i<sub>0</sub>,i<sub>k</sub>

## Порядок роста функции

- lim f(x)/g(x) = 0 where x -> inf => f(x) ~ o(g(x)) - растет медленнее чем g(x)
- lim f(x)/g(x) = const where x -> inf => f(x) ~ O(g(x)) - растет не быстрее чем g(x)
- lim f(x)/g(x) = const != 0 where x -> inf => f(x) ~ &theta;(g(x)) - растет также

### Примеры

- f(x) ~ &theta;(x) => f(x) - линейная
- f(x) ~ &theta;(x<sup>2</sup>) => f(x) - квадратичная
- f(x) ~ &theta;(x<sup>k</sup>) where k=const => f(x) - полиномиальная
- f(x) ~ &theta;(k<sup>x</sup>) => f(x) - экспоненциальная
- f(x) ~ &theta;(log(x)) => f(x) - логарифмическая
