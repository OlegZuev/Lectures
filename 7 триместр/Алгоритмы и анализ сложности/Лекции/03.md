# Лекция 3

02.10.20

- [Лекция 3](#лекция-3)
  - [Решение уравнения](#решение-уравнения)
  - [Задача о Ханойской башне](#задача-о-ханойской-башне)
  - [Оценка сложности задачи](#оценка-сложности-задачи)
    - [Классы сложности задачи](#классы-сложности-задачи)
      - [Класс P (полиномиальные)](#класс-p-полиномиальные)
      - [Класс EXP (экспоненциальные)](#класс-exp-экспоненциальные)
      - [Машина Тьюринга](#машина-тьюринга)
      - [Недетерминированная машина Тьюринга (НМТ)](#недетерминированная-машина-тьюринга-нмт)
      - [Класс NP (полиномиальные на НМТ)](#класс-np-полиномиальные-на-нмт)
      - [Задачи оптимизации и задачи принятия решений (ЗПР)](#задачи-оптимизации-и-задачи-принятия-решений-зпр)
      - [Альтернативное определение класса NP](#альтернативное-определение-класса-np)
  - [TQBF (true quantified boolean function)](#tqbf-true-quantified-boolean-function)

## Решение уравнения

    t_alpha(n) = a * T(n/d) + b * n^k, n = d^m, m = log_d(n)

    1) t_alpha(d^m) = C_1 * a^m + m * A * (d^m)^k if d^k = a

    2) t_alpha(d^m) = C_1 * a^m + A * (d^m)^k otherwise
    a^m = a^log_d(n) = (a^log_a(n))^log_d(a) = n^log_d(a)
    log_d(n) = log_a(n) * log_d(a)

    3) t_alpha(d^m) = d^(k * m) + m * A * d^(k * m) ~ Theta(m * A * (d^m)^k)

    2.1) if a > d^k then t_alpha(d^m) ~ Theta(a^m)
    2.2) if a < d^k then t_alpha(d^m) ~ Theta((d^m)^k)

    Result: t_alpha(n) ~ Theta(log_d(n) * n^k) if a = d^k
            t_alpha(n) ~ Theta(n^log_d(a)) if a > d^k
            t_alpha(n) ~ Theta(n^k) if a < d^k

__Пример (сортировка слияниями)__:

    t_alpha(n) = a * t_alpha(n / 2) + b * n^k
    a = 2, d = 2, k = 1

    t_alpha(n) ~ Theta(log_2(a) * n)

## Задача о Ханойской башне

1. Перекладываем n-1 дисков с A на C.
2. Перекладываем 1 диск с A на C.
3. Перекладываем n-1 диск с C на B.

        H(n, x, y, z) - перенос башни из n дисков со стержня x на y, z - вспомогательный диск
        One(x, y) - перенос одного диска со стержня x на y

        H(n, x, y, z)
        {
            if (n > 0)
            {
                H(n - 1, x, z, y);
                One(x, y);
                H(n - 1, z, y, x);
            }
        }

        Пусть t_One = p
        t_H(n) = 1 + t_H(n - 1) + p + t_H(n - 1) + 2
        t_H(0) = 1

        z_n = 3 + p + 2 * z_(n-1)
        z_0 = 1

        1) z_n = 2*z(n-1)
        lambda = 2
        z_n^(о.о.) = C_1 * 2^n

        2) z_n(ч.н.)
        резонанса нет
        A = 3 + p + 2*A, A = -(3 + p)

        3) z_n = C_1 * 2^n - (3 + p)
        z_0 = C_1 - (3 + p) = 1
        C_1 = 4 + p

        z_n = (4 + p) * 2^n - (3 + p)

        t_H(n) = (4 + p) * 2^n - (3 + p) ~ Theta(2^n)

## Оценка сложности задачи

### Классы сложности задачи

#### Класс P (полиномиальные)

Задача T принадлежит классу P, если существует алгоритм alpha, решающий задачу T, при этом t_alpha(n) ~ O(poly(n)), т. е. существует константа d такая, что t_alpha(n) ~ O(n^d).

    Примеры: перемножение матриц, поиск кратчайшего пути в графе, сортировка.

#### Класс EXP (экспоненциальные)

Задача T принадлежит классу EXP, если T не принадлежит P, но существует алгоритм alpha, решающий задачу T, при этом существует константа d такая, что t_alpha(n) ~ O(d^n).

    Примеры: Ханойская башня.

Есть задачи, для которых нет алгоритмов полиномиальной сложности, но не доказано их отсутствие.

    Примеры: задача о рюкзаке, поиск гамильтонова цикла.

#### Машина Тьюринга

Программа - набор команд.

Команда:

    a_i, q_j -> a_k, q_l, D_m

    a_i, a_j - символы алфавита
    q_j, q_l - состояния
    D_m from {L, R, S}

Классическая детерминированная машина.

#### Недетерминированная машина Тьюринга (НМТ)

Программа - набор команд.

Команда:

    a_i, q_j -> a_k1, q_l1, D_m1
                a_k2, q_l2, D_m2
                ...
                a_kn, q_ln, D_mn

    Т. е. существует n альтернатив.
    В каждый момент некоторым образом выбирается одна из n альтернатив.

#### Класс NP (полиномиальные на НМТ)

Задача T принадлежит классу NP, если существует алгоритм alpha для __НМТ__, решающая задачу T : t_alpha(n) ~ Theta(poly(n)).

__Замечание__: любая программа для ДМТ является частным случаем программы для НМТ. Таким образом, если какая-то задача принадлежит классу P, то она автоматически принадлежит классу NP.

#### Задачи оптимизации и задачи принятия решений (ЗПР)

__Задачи принятия решения__ - задачи, в которых выходным значением является булево значение (0 или 1).

    Примеры: существует ли в графе гамильтонов цикл, существует ли в графе полный подграф и т. д.

__Задача оптимизации__:

    Примеры: сортировка (требуется минимизировать число перестановок), задача о рюкзаке.

Задачи оптимизации не проще соответствующих задач принятия решения.

Далее будем рассматривать только задачи принятия решения.

#### Альтернативное определение класса NP

Задача T принадлежит классу NP, если t(x) = 1 тогда и только тогда, когда существуют дополнительные данные y, объем которых является полиномом от объема исходных данных x, и существует задача t' такая, что t'(x, y) = 1 и при этом задача t' принадлежит классу P.

## TQBF (true quantified boolean function)

    ? x1 ? x2 ? x3 ... ?

    xn F(x1, x2, x3, ..., xn) = 1?

    V x1 ] x2 V x3 ...
