ex 1

a) Best Fit

int containersUsed = 0
for (int i = 0; i < N; i++) // просматриваем все предметы
{
    int k = -1 // лучший контейнер на данный момент
    for (int j = 0; j < containersUsed; j++) // просматриваем все контейнеры
    {
        if (предмет после добавления в j-ый контейнер оставляет меньше свободного места, чем при добавлении в k-ый контейнер)
        {
            k = j // запоминаем лучший контейнер
        }
    }
    положить предмет в k-ый контейнер
}

Т. к. в худшем случае каждый предмет потребует новый контейнер (т. е. не поместится ни в один предыдущий), то потребуется поместить N предметов в N контейнеров, и тогда сложность алгоритма - O(n^2).

b) Best Fit With Sort

objects.SortByDesc(object.Weight) // сортируем объекты
BestFit(objects) // сводим задачу к предыдущему случаю

Сортировка - O(n logn), Best Fit - O(n^2) => BFS имеет сложность O(n^2).

ex 2

предметы	удельная ценность (desc)
b			9
c			6
a			5
d			5
f			4
g			3
e			1

предмет		действие	свободное место		суммарная стоимость
b			берем		10					90
c			берем		7					108
a			берем		5					118
d			пропускаем	5					118
f			берем		0					138

Ответ: надо брать a, b, c, f; суммарная стоимость составит 138.

ex 3

a)

вершина		степень (desc)	цвет
d			5				1
f			4				1
b			3				2
g			3				2
k			3				3
c			2				2
e			2				2
h			2				1
j			2				2
l			2				1
m			2				3
p			2				1
a			1				2
i			1				1
n			1				2
o			1				2

Ответ: достаточно 3 цветов; раскраска приведена выше.

b)

1. Приближенный алгоритм

U = {A, B, C, D, E, F, G, H, I, J, K, L, M, P }
len(U) = 14

2. Приближенный алгоритм (жадный)

U = {B, D, F, G, H, I, J, K, M}
len(U) = 9

Вывод: приближенный жадный алгоритм показывает лучшие результаты (9 вершин против 14 у приближенного).
