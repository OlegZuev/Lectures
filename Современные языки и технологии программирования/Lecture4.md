# Лекция 4

30.01.20

- [Лекция 4](#Лекция-4)
  - [Классы](#Классы)
    - [Типы данных](#Типы-данных)
    - [Классы типов](#Классы-типов)
    - [Ограничения класса](#Ограничения-класса)
    - [Аннотация типов](#Аннотация-типов)
  - [Рекомендуемая литература](#Рекомендуемая-литература)
  - [Лямбда-выражения](#Лямбда-выражения)
    - [Композиция функций](#Композиция-функций)
  - [Функторы](#Функторы)
  - [Монады](#Монады)
  - [Lisp](#lisp)
  - [Прочее](#Прочее)

## Классы

### Типы данных

Int (4 байта), Integer (неограниченный), Float, Double, Bool, Char, кортежи, списки.

### Классы типов

Интерфейс, содержащий набор функций.

Если тип является экземпляром класса, то он поддерживает и реализует его функции.

1. Eq - == /= (все встроенные типы)
2. Ord - Eq, <, <=, >, >=, compare
3. Show - show - превращает значение определенного типа в строку (все встроенные типы)
4. Read - read - позволяет превратить строку в значение определенного типа (все встроенные типы)
5. Num - арифметические операции (Int, Integer, Float, Double) (все встроенные типы)

Замечание: достаточно определить только == или compare, чтобы определились другие операции Eq или Ord.

 Класс в C# != класс в Haskell.
 Класс в C# = тип в Haskell.
 Интерфейс в C# = класс в Haskell.

В языке Haskell автоматически определяется класс типов. Автоматически определяется тип параметров функции, а не только тип переменных.

### Ограничения класса

Ограничение класса => тип данных

```haskell
Num a => a
```

```haskell
Eq a => [a]
```

### Аннотация типов

Компилятор не сможет правильно определить тип без аннотации типа:

```haskell
(read "5" :: Float) + 2 -- 7.0
```

## Рекомендуемая литература

1. М. Липовача "Изучая Haskell во имя добра"
2. Душкин "Функциональное программирование на языке Haskell"

## Лямбда-выражения

Безымянные функции.

\аргументы -> значение

Оставляем в списке значения больше нуля:

```haskell
filter (\x -> x > 0) lst
```

### Композиция функций

f . g = \x -> f (g x)

## Функторы

__Функтор (Functor)__ - класс типов, в котором поддерживается функция fmap.

fmap :: (a -> b) -> f a -> f b

f a - некоторый конструктор. Из значения a конструируется значение.

f b - тот же самый конструктор, примененный к значению b.

 Аналогичная функция:

 ```hs
 map :: (a -> b) -> [a] -> [b]
 ```

 Берем список типа a и получаем список типа b. Т. е. мы распаковываем список, преобразуем его элементы и запаковываем обратно.

## Монады

Вводимое значение упаковывается и преобразуется чистыми функциями, если является корректным. В противном случае, некорректное значение обратно запаковывается.

## Lisp

Функциональный язык программирования.

LISt Processing.

Функции и данные представляются в виде списков.

Первый элемент списка - имя функции. Все последующие элементы - аргументы.

```lisp
(f a b ...)
```

Если присутствует апостроф, то первое значение не воспринимается как имя функции.

```lisp
`(a b ...)
```

Списки могут содержать списки.

## Прочее

Генетические алгоритмы - выбирается наилучший вариант из нескольких случайных. Затем комбинируются различные хорошие варианты. Относится к эвристическим методам.
