# Лекция 10

12.03.20

## Множественное наследование

### Модификаторы прав доступа при наследовании

```cpp
class B : [modifier] A {}
```

Уровни доступа в производном классе B

| -                 | public  | protected | private |
| ----------------- | ------- | --------- | ------- |
| public            | public  | protected | -       |
| private (default) | private | private   | -       |

```cpp
class A
{
public:
    int x;
}

class B
{
public:
    char x;
}

class C : public A, public B
{
}

void foo()
{
    C c1;
    // c1.x;
    c1.A::x = 15;
    c1.B::x = 'Z';
}
```

### Ромбовидное наследование

```cpp
class P
{
public:
    int y;
}

class A : public P
{
}

class B : public P
{
}

class C : public A, public B
{
}

void foo()
{
    C c1;

    // Два разных поля
    c1.A::y = 1999;
    c2.B::y = 2001;
}
```

Решение проблемы: виртуальное наследование.

### Виртуальное наследование

Наследуются не копии полей, а ссылки.

```cpp
class A : virtual public P
{
}

class B : virtual public P
{
}

class C : [virtual] public A, [virtual] public B
{
}

void foo()
{
    C c1;
    c1.y = 1999;
}
```

## Автоматное программирование

__Автомат__ - математическая модель. Автомат - модель реальных устройств, не учитывающих физические особенности.

Схема автомата:

Входной сигнал x(t) -> Автомат + память (состояние автомата) -> Выходной сигнал y(t)

Автомат -- (новое состояние q(t)) -> Память

Память -- (текущее состояние (t-1)) -> Автомат

y(t) = f(x(t), q(t-1))

q(t) = g(x(t), q(t-1))

| q(t-1), x(t) | a_1                      | a_2 | a_3 |
| ------------ | ------------------------ | --- | --- |
| q_1          | f(a_1, q_1), g(a_1, q_1) | ... | ... |
| q_2          | ...                      | ... | ... |
| q_3          | ...                      | ... | ... |

Диаграмма Мура.

Память = память автомата + память с промежуточными результатами.

__Центральная идея автоматного программирования__ - отделение описания логики поведения от описания смысла каждого действия. При этом описание логики строго структурировано. Автоматный подход рационально использовать при создании только тех компонент системы, которые обладают сложным поведением, т. е. в качестве реакции на некоторое входное воздействие система может осуществить одно из нескольких выходных воздействий, при этом выбор может зависеть от предыстории.

### Различия памяти и состояния

В состоянии системы должны быть выделены управляющие и вычислительные переменные. Логика поведения должна зависеть только от управляющих переменных.
